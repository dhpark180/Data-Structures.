Array (배열), List (리스트)

a. 데이터를 연속적인 메모리 공간에 저장하고, 저장된 곳의 주소(address, reference)를
통해 매우 빠른 시간에 접근할 수 있는 가장 많이 쓰이는 기본적인 자료구조
b. C, C++, java, Python 등의 언어에서는 모두 array 자료구조 지원 (Python에서는 list,
array 등의 자료구조가 배열 자료구조임)


Python 언어에서의 list A

항상 객체의 주소만 저장하기 때문에, 리스트의 셀의 크기를 메모리의 주소를
표현할 수 있는 (4 바이트 또는) 8 바이트로 고정하면 된다. 모든 셀의 크기가
같기 때문에 index에 의해 O(1) 시간 접근이 가능하다

파이썬의 리스트는 읽기/쓰기 이외에 훨씬 더 유연하고 강력한 연산을 지원한다

1. A.append(value): 맨 오른쪽 (뒤)에 새로운 값 value를 삽입

2. A.pop(i): A[i] 값을 지운 후 리턴 (i번째 오른쪽 값들은 왼쪽으로 한
칸씩 당겨져, cell의 수가 하나 감소)
a. pop()은 맨 오른쪽 값을 지움

3. A.insert(i, value): A[i] = value 연산 (단, A[i], A[i+1], …
값들은 오른쪽으로 한 칸씩 이동해 A[i]를 비운 후, value 값 저장)

4. A.remove(value): value를 찾아 제거 (value 오른쪽의 값들은
왼쪽으로 한 칸씩 이동해 빈 공간을 메꿈)

5. A.index(value): value 값이 처음으로 등장하는 index 리턴

6. A.count(value): value 값이 몇 번 등장하는 지 횟수를 세어 리턴

7. A[i:j] : A[i], …, A[j-1]까지를 복사해 새로운 리스트 생성하여
리턴

a. slicing 연산이라 부름
b. B = A[i: j]라고 하면 A[i], …, A[j-1]까지가 복사되어 B가
됨. A는 전혀 변화가 없음에 유의!

8. value in A: 멤버십 연산자 - A에 value가 있으면 True, 없으면 False

리스트는 동적배열이다!

1. C 언어의 배열과의 또 다른 중요한 차이점은 list의 크기 (셀의 개수)가
필요에 따라 자동으로 증가, 감소한다는 것이다

>>> A = []
>>> sys.getsizeof(A)
64 # 빈 리스트도 64 바이트 할당
# 실제 컴퓨터마다 초기 할당양이 다름
>>> A.append("Python") # append 후 96 바이트로 재 할당
>>> sys.getsizeof(A)
96

2.그래서 append 또는 insert 연산을 위한 공간(메모리)이 부족하면 더 큰
메모리를 할당받아 새로운 리스트를 만들고 이전 리스트의 값을 모두
이동한다. 반대로 pop 연산을 하면서 실제 저장된 값의 개수가 리스트
크기에 비해 충분히 작다면 더 작은 크기의 리스트를 만들고 모두
이동한다 ⇒마치, 식구가 많으면 큰 집으로 이사하고, 식구가 줄어들면
작은 집으로 이사하는 것과 같은 방식임

3. 이렇게 필요에 따라 크기가 변하는 배열을 동적 배열 (dynamic array)라
부른다 (C에서의 배열은 동적 배열이 아니므로 사용자가 직접 상황에
맞게 처리해야 한다) 따라서 사용자는 배열의 크기를 전혀 신경쓰지
않아도 된다!

4.동적 배열인 list를 위해선 python 내부적으로 현재 list의
크기(capacity)와 list에 저장된 실제 값의 개수(n)를 항상 알고 있어야
한다
a. 이를 위한 내부 변수가 필요하므로 빈 리스트 A는 0바이트보다 클
수 밖에 없다

5. 추가 메모리 이외에 연산 시간에도 영향을 준다. 특정 append 연산에서
메모리를 늘려야 한다면 이전 리스트의 값을 새로운 리스트로 일일이
이동해야 한다 

def append(A, value):
  1. if A.capacity == A.n: # resize 필요!
    a. allocate a new list B with larger memory
    b. update B.capacity and B.n
    c. for i in range(A.n):
      B[i] = A[i]
    d. dispose A
    e. A = B # B 이름을 A로 바꿈
  2. A[n] = value
  3. A.n += 1
  
6. 단계 1.c에서 A에 저장된 값의 개수만큼 시간이 걸림: O(n)

결국, resize가 일어나지 않는 append 연산은 O(1) 시간, 일어나는
경우엔 O(n) 시간이 걸림

7. 그러나 resize가 append 할 때마다 발생하는 것이 아니라 가끔 발생하는
것이라 평균 시간을 계산해보면 O(n) 시간보다 훨씬 작다
8. 2배씩 크기를 증가하거나 반으로 감소하는 경우엔 append, pop 연산
시간은 평균적으로 O(1)임을 증명할 수 있다.

수행시간:
1. A[i] = A[j] + 1
a. A[j] 값을 읽은 후 (단위시간) 1을 더하고 (단위시간) A[i]에 쓴다
(단위시간) (읽기/쓰기: O(1) 시간)
2. A.append(5)
a. 맨 오른쪽에 삽입. 평균적으로 O(1) 시간
